<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Shangri-La Frontier: The Game</title>
    <style>
        body { margin: 0; background: #111; display: flex; justify-content: center; align-items: center; height: 100vh; color: #00ffcc; font-family: 'Courier New', Courier, monospace; overflow: hidden; }
        canvas { border: 4px solid #00ffcc; background: #000; image-rendering: pixelated; box-shadow: 0 0 20px #00ffcc; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <h2>PLAYER: <span id="pName">SUNRAKU_CLONE</span></h2>
        <p>HP: <span id="hp">100/100</span> | STAMINA: <span id="stamina">50</span></p>
        <p>AGI: <span id="agi">99</span> (LUK: <span id="luk">50</span>)</p>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 800;
canvas.height = 400;

// --- GAME STATE & STATS (The SLF System) ---
const GameState = {
    gravity: 0.8,
    friction: 0.9,
    keys: {}
};

class Character {
    constructor() {
        // Base Stats (Customizable like the anime)
        this.stats = { hp: 100, maxHp: 100, agi: 99, str: 15, luk: 50, stamina: 100 };
        this.pos = { x: 50, y: 300 };
        this.vel = { x: 0, y: 0 };
        this.width = 64;  // Visual size
        this.height = 64; // Visual size
        this.grounded = false;
        this.frame = 0;
        this.state = 'IDLE'; // IDLE, RUN, JUMP, ATTACK
    }

    update() {
        // Movement Logic (High Speed AGI scaling)
        let moveSpeed = 0.5 + (this.stats.agi / 200);
        if (GameState.keys['ArrowRight']) this.vel.x += moveSpeed;
        if (GameState.keys['ArrowLeft']) this.vel.x -= moveSpeed;
        
        // Jump Logic (Sunraku style double jump placeholder)
        if (GameState.keys['Space'] && this.grounded) {
            this.vel.y = -15;
            this.grounded = false;
        }

        // Physics
        this.vel.y += GameState.gravity;
        this.pos.x += this.vel.x;
        this.pos.y += this.vel.y;
        this.vel.x *= GameState.friction;

        // Ground Collision
        if (this.pos.y > 336) {
            this.pos.y = 336;
            this.vel.y = 0;
            this.grounded = true;
        }

        this.animate();
    }

    animate() {
        // Simple frame counter
        if (Math.abs(this.vel.x) > 0.1) {
            this.state = 'RUN';
            this.frame = (this.frame + 0.1) % 8; // Assumes 8 frame walk
        } else {
            this.state = 'IDLE';
            this.frame = (this.frame + 0.05) % 4;
        }
    }

    draw() {
        // The "Fix" for uncentered art:
        // Instead of just drawing the image, we draw a rectangle first
        // to ensure the hitbox is perfect while we wait for your sprites.
        ctx.fillStyle = "#00ffcc";
        ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
        
        // Weapon / Effect Overlay (Vorpal Strike Visual)
        if (GameState.keys['KeyZ']) {
            ctx.strokeStyle = "white";
            ctx.strokeRect(this.pos.x + 40, this.pos.y, 40, 64);
            document.getElementById('stamina').innerText = "STRIKE!";
        }
    }
}

const player = new Character();

// --- INPUT LISTENERS ---
window.addEventListener('keydown', e => GameState.keys[e.code] = true);
window.addEventListener('keyup', e => GameState.keys[e.code] = false);

// --- MAIN LOOP ---
function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw Floor
    ctx.fillStyle = "#333";
    ctx.fillRect(0, 380, canvas.width, 20);

    player.update();
    player.draw();

    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
